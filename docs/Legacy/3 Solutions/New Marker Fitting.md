
> [!WARNING] This note was automatically generated by AI based on daily notes, inaccuracies may exist.

>[!info|right]
> **Part of a series on**
> ###### [[Dataset Overview|Van Criekinge]]
> ---
> **Solutions**
> * [[3 Solutions/New Marker Fitting|New Marker Fitting]]
> * [[3 Solutions/Old Fitting Code Explanation|Old Fitting Code]]
> * [[Tools/Visualization Setup|Visualization Setup]]

>[!info]
> ###### New Marker Fitting
> [Type::Technical Solution]
> [Script::fit_smpl_markers.py]
> [Status::Implemented]
> [Fixes::5 Critical Issues]

This document explains the **new SMPL marker fitting code**, detailing bug fixes and architectural improvements that enable correct processing of the Van Criekinge dataset.


## Legacy Fitter Issues
The legacy `2_fit_smpl_markers.py` produced motions with several critical defects:

1.  **Sideways Pelvis**: Left leg attached to front, right leg to back.
2.  **Jiggly Spine**: The spine appeared to twist and jiggle during walking.
3.  **Forward Lean**: The character leaned forward unnaturally.
4.  **Drifting Motion**: The character drifted on the Y-axis and moved sideways.
5.  **Backward Knees**: Knees occasionally bent in the wrong direction.

> [!warning] Root Cause
> The legacy fitter used a hand-crafted, incorrect coordinate frame calculation in `estimate_root_init()`. It manually constructed axes from markers (`up = u0 - p0`, etc.) and assembled a rotation matrix that did not correctly transform Vicon coordinates (Z-up, Y-forward) to SMPL coordinates (Y-up, Z-forward).


---

## New Fitter: Key Architectural Fixes

### 1. Proper Vicon→SMPL Coordinate Transformation

The new code introduces a dedicated function `vicon_to_smpl_coords()`:

```python
def vicon_to_smpl_coords(points, vicon_up='Z', vicon_forward='Y'):
    if vicon_up == 'Z' and vicon_forward == 'Y':
        rot = R.from_euler('x', -90, degrees=True).as_matrix()
    # ...handles other conventions...
    return (rot @ points_flat.T).T.reshape(original_shape)
```
This is applied **once** to all marker data before any processing, ensuring the entire pipeline operates in a consistent SMPL-native Y-up coordinate system.

### 2. Procrustes Alignment (Kabsch Algorithm)

> [!IMPORTANT]
> The legacy code used a **similarity transform** (Rotation + Translation + **Scale**). Since SMPL uses `betas` for body size (not a global scale), this was mathematically incorrect and caused translation errors.

The new code uses a **rigid Kabsch alignment** (Rotation + Translation only):

```python
def procrustes_align(source, target):
    """Rigid Kabsch alignment (rotation + translation, no scale)."""
    # ...
    H = src_centered.T @ tgt_centered
    U, S, Vt = np.linalg.svd(H)
    R_mat = Vt.T @ U.T
    # ...
    t = tgt_mean - (R_mat @ src_mean)  # No scale factor!
    return R_mat, t
```

### 3. Multi-Pass Fitting with Outlier Detection

The new fitter uses a **three-phase approach**:

| Phase | Description |
|-------|-------------|
| **Pass 1** | Standard marker-to-joint optimization. |
| **Pass 2** | `detect_outlier_frames()` identifies frames with sudden pose jumps (using MAD). These frames are re-initialized from a stable reference frame (middle of sequence) and re-fit with **stronger temporal smoothing weights**. |
| **Final Pass** | A light refinement pass after Gaussian smoothing to ensure marker accuracy. |

```python
outlier_frames = detect_outlier_frames(full_pose, threshold=2.5)
# Re-initialize bad frames with blending from reference_frame
# ...
fit_sequence_single_pass(..., w_pose_vel * 3, w_pose_acc * 3, ...)  # Stronger smoothing
```

### 4. Travel Direction Awareness (Foot Orientation Prior)

A new `estimate_travel_direction()` function computes the movement direction from the smoothed translation velocity. This direction is used to add a **foot orientation prior** that encourages the feet to point forward when moving.

```python
l_dot = (l_foot_dir_xz * travel_direction_torch).sum(dim=1)
# Loss encourages l_dot to be close to 1 (foot pointing in direction of travel)
foot_orient_loss = ((1 - l_dot[movement_mask]) ** 2).mean()
```

### 5. Enhanced Smoothness Constraints

| Constraint | Legacy | New |
|------------|:------:|:------:|
| Translation Velocity/Acceleration | ✓ | ✓ |
| Pose Velocity/Acceleration | ✗ | ✓ |
| **Spine-Specific** Smoothness | ✗ | ✓ |
| **Foot Smoothness** | ✗ | ✓ |
| Gaussian Post-Smoothing (`smooth_sigma`) | ✗ | ✓ |

---

## Subsequent Bug Fixes (Dec 12)

After the initial implementation, several additional bugs were identified and fixed:

### Fix 1: `movement_mask` Logic Error
**Problem**: The mask was based on `torch.norm(travel_direction_torch) > 0.5`, but the direction vector is always unit-length. This made the mask `True` even when standing still.

**Fix**: Return `travel_speed` (in m/s) from `estimate_travel_direction()` and use that instead:
```python
movement_mask = travel_speed_torch > 0.05  # meters per second
```

### Fix 2: Procrustes Overweighting of Pelvis
**Problem**: `LASI`, `RASI`, `SACR` all map to the pelvis joint. This causes the pelvis position to be weighted 3x in Procrustes alignment, biasing the result.

**Fix**: Group markers by their target joint and average their positions before alignment:
```python
joint_to_marker_idxs = defaultdict(list)
for m, jid in marker_joint_map.items():
    if m in name2idx:
        joint_to_marker_idxs[jid].append(name2idx[m])
# Each joint appears only once in alignment
tgt_pts = np.array([markers_np[t, idxs, :].mean(axis=0) for jid, idxs in ...])
```

### Fix 3: Stale Travel Direction
**Problem**: `travel_direction` was computed once from `transl_init` and never updated. After optimization, `fitter.transl` can change significantly, making the foot-orient prior inaccurate.

**Fix**: Add an `update_travel_from_current_transl()` helper function and call it after Pass 1 and Pass 2.
```python
def update_travel_from_current_transl():
    transl_now = fitter.transl.detach().cpu().numpy()
    td, sp = estimate_travel_direction(transl_now, fps)
    return (torch.from_numpy(td).float().to(device), ...)
```

### Fix 4: Removal of Dead `joint_offsets` Parameter
**Problem**: `joint_offsets` was initialized with `requires_grad=False`, meaning it could never update. The code computed `offset_l2` loss and included it in the optimizer, which was dead logic.

**Fix**: Removed all `joint_offsets` related code entirely. The `forward()` method now simply returns `joints`.

### Fix 5: FPS-Agnostic Speed Threshold
**Problem**: `travel_speed` was in units of m/frame, not m/s. A threshold of `0.001` meant different physical speeds at 100 FPS vs 20 FPS.

**Fix**: `estimate_travel_direction()` now converts speed to m/s (`speed_mps = speed_per_frame * fps`).

### Fix 6: Early Frame "Knee Outwards" Issue
**Problem**: The knee twisted outwards on the first few frames before settling.

**Fix**: Force early frames (0-4) to have a higher blend factor (0.9) from the reference frame during re-initialization in Pass 2:
```python
if frame_idx < 5:
    blend = 0.9  # Force early frames to be very close to reference
else:
    blend = max(0.3, 1.0 - dist / 20.0)
```

---

## CLI Options (New)

The new fitter exposes many tunable parameters:

- `--vicon_up`, `--vicon_forward`: Specify the input coordinate system.
- `--w_pose_vel`, `--w_pose_acc`: Pose smoothness weights.
- `--w_spine_vel`, `--w_spine_acc`: Spine-specific smoothness.
- `--w_foot_orient`, `--w_foot_smooth`: Foot orientation and smoothness priors.
- `--no_two_pass`: Disable the multi-pass fitting.
- `--smooth_sigma`: Control Gaussian post-smoothing (0 to disable).
